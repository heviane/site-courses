<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>JavaScript</title>
        <link rel="stylesheet" href="../style.css">
    </head>
    <body>
		<!--Página-Cabeçalho-->
		<header class="header">
			<h1>Aula #14 - Introdução a Design Patterns</h1>
		</header>
		<!--Página-Conteúdo-->
		<section class="content">
			<article class="content_item">
                <header>
					<h2>Definição</h2>
				</header>
				Design Patterns = Padrões de Projetos <br/>
				São soluções generalistas para problemas recorrentes durante o desenvolvimento de software.<br>
				Não se trata de um framework ou código pronto, mas de uma definição de alto nível de como um problema comum pode ser solucionado.<br>
				<li>Em 1978 surgiu o livro <b>"A Pattern Language"</b> apresentando 253 tipos de problemas/desafios de projeto.</li>
				<li>Em 1987, Kent Beck e Ward Cunningham apresentaram 5 padrões de projetos em uma palestra chamada <b>Using Pattern Languages for Object-Orientated Program</b></li>
				<li>Em 1994, Gang of four (GoF) apresentou um livro chamado <b>Design Patterns: Elements of Reusable Object-Oriented Software</b> que contém mais de 50 padrões de projetos.</li>
            </article>
			<article class="content_item">
                <header>
					<h2>Formato</h2>
				</header>
				<li>Nome</li>
				<li>Exemplo</li>
				<li>Contexto</li>
				<li>Problema</li>
				<li>Solução</li>
            </article>
            <article class="content_item">
                <header>
					<h2>Tipos de Padrões (Três categorias)</h2>
				</header>
				<h3>Padrões de Criação</h3>
					São aqueles que abstraem e/ou adiam o processo de criação de objetos. <br>
					Ajudam a tornar um sistema independente de como seus objetos são criados, compostos e representados.
						<li>Abstract Factory</li>
						<li>Builder</li>
						<li>Factory Method</li>
						<li>Prototype</li>
						<li>Singleton</li>

				<h3>Padrões Estruturais</h3>
					Se preocupam com a forma como classes e objetos são compostos para formar estruturas maiores.
						<li>Adapter</li>
						<li>Bridge</li>
						<li>Composite</li>
						<li>Decorator</li>
						<li>Facade</li>
						<li>Business Delegate</li>
						<li>Flyweight</li>
						<li>Proxy</li>

				<h3>Padrões Comportamentais</h3>
					Se concentram nos algoritmos e atribuições de responsabilidades entre os objetos. Eles não descrevem apenas padrões de objetos ou de classes, mas também padrões de comunicação entre os objetos.
					<li>Chain of Responsibility</li>
					<li>Command</li> 
					<li>Interpreter</li>
					<li>Iterator</li>
					<li>Mediator</li>
					<li>Observer</li>
					<li>State</li>
					<li>Strategy</li>
					<li>Template Method</li>
					<li>Visitor</li>
            </article>
			<article class="content_item">
                <header>
					<h2>Patterns mais utilizados em JavaScript</h2>
				</header>
				<h3><li>Factory</li></h3>
				Todas as funções que retornam um objeto, sem a necessidade de chamá-las com o <b>new</b>, são consideradas <b>funções Factory (fábrica)</b>.<br> 
				
				<h3><li>Singleton</li></h3>
				O objetivo é criar uma única instância de uma função construtora e retorná-la toda vez em que for necessário utilizá-la.<br>Exemplo: <a href="https://jquery.com" target="_blank">https://jquery.com</a><br>
				
				<h3><li>Decorator</li></h3>
				Função decorator recebe outra função como parâmetro e estende o seu comportamento sem modificá-la explicitamente<br>
				Já tem a <b>proposta para JavaScript</b>:
				<a href="https://github.com/tc39/proposal-decorators" target="_blank">https://github.com/tc39/proposal-decorators</a><br>
				Já está <b>disponível em TypeScript</b>, basta colocar o <b>"@"</b> na frente que já é Decorator: 
				<a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank">https://www.typescriptlang.org/docs/handbook/decorators.html</a>
				
				<h3><li>Observer</li></h3>
				A instância (subscriber) mantém uma coleção de objetos (observers) e notifica todos eles quando ocorrem mudanças no estado.
				<br>
				<b>Vue:</b><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js" target="_blank">https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js</a>
				<br>
				<b>RxJs (Tem no angular):</b><a href="https://rxjs-dev.firebaseapp.com/guide/observable" target="_blank">https://rxjs-dev.firebaseapp.com/guide/observable</a>
                
				<h3><li>Module</li></h3>
				Possibilita organizar código em arquivos separados, reutilizando-os via importação.<br>
				Sem a necessidade de expor variáveis globais.<br>
				**Já tinha no JS, mas ficou mais fácil no ES6.<br>
            </article>
		</section>
		<!--Página-Rodapé-->
		<footer class="footer"></footer>

		<script>
			// =============================== Design Pattern: Factory ===============================
			// ---- Exemplo NÃO Factory
			function FakeUser(){
				this.name = "Fake User";
				this.lastName = "Fake Last Name";
			}
			const user = new FakeUser();
			console.log(user);
			// ---- Exemplo SIM Factory
			function Pessoa(name){
				return {
					name,
					lastName: 'Bastos'
				}
			}
			const p1 = Pessoa('Heviane');
			console.log(p1);
			// ---- Exemplo SIM Factory
			function Pessoa(customProperties){
				return {
					name: 'Heviane',
					lastName: 'Bastos',
					...customProperties 
				}
			}
			const p2 = Pessoa({name: 'Maria', age: 58}); // Sobrescrever name e add att age
			console.log(p2);
			// =============================== Design Pattern: Singleton ===============================
			// Exemplo: Variável global
			var SETTINGS = {
				api: 'http://localhost',
				trackJsToken: '12345'
			}
			// Exemplo: Singleton
			function MyApp(){
				if(!MyApp.instance){// Caso a var instance não esteja definida, ela é instanciada
					MyApp.instance = this; // instance é apenas uma propriedade p controlar se foi ou não instanciada
				}
				return MyApp.instance;// Sempre vai retornar a mesma instância
			}
			// Exemplo: Singleton
			function Pessoa(){
				if(!Pessoa.instance){
					Pessoa.instance = this;
				}
				return Pessoa.instance;
			}
			const p3 = Pessoa.call({name:'pedro'});
			const p4 = Pessoa.call({name:'nina'});
			console.log(p3); // {name: 'pedro'}
			console.log(p4); // {name: 'pedro'}
			//Após instanciado p 1º vez, sempre vai retornar mesma instância, mesmo q tentem sobrescrever(explicitar contexto diferente).

			// =============================== Design Pattern: Decorator ===============================
			/* Vamos supor que queremos controlar a execução de uma função.
				Essa função somente vai ser executada se usuário estiver autenticado.
				Aqui no JS sem a sintaxe de decoration. */
			let loggedIn;
			// Função decorator recebe outra função como parâmetro e estende o seu comportamento sem modificá-la explicitamente
			function callLogin(fn){ // Função decorator que controla a execução da função sum(), p permitir somente se logado
				return loggedIn && fn();
			}
			function sum(a, b){
				return a + b;
			}
			loggedIn = false;
			console.log(callLogin(() => sum(1, 2))); // false = Não vai executar a função sum()
			loggedIn = true;
			console.log(callLogin(() => sum(1, 2))); // 3 = Sim vai executar a função sum()

			// // Outro exemplo, usando a sintaxe decoration
			// function readonly(target, name, descriptor){
			// 	descriptor.writable = false;
			// 	return descriptor;
			// }
			// class Job {
			// 	@readonly
			// 	title(){ return 'CEO' };
			// 	// definindo propriedade title e definindo que é somente de leitura
			// }
			// // Outro exemplo no angular
			// @component({
			// 	selector: 'app-reactive-favorite-color',
			// 	template: 'Favorite color:<input type="text" [formControl]="favoriteColorControl">'
			// })
			// export class FavoriteColorComponent{
			// 	favoriteColorControl = new FormControl('');
			// }
			
			// =============================== Design Pattern: Observer ===============================
			// A instância (subscriber) mantém uma coleção de objetos (observers) e notifica todos eles quando ocorrem mudanças no estado.
			// Fica escutando os observers e toda vez q houver alguma alteração fica responsável por chamar todos os subscribers.
			/* EXEMPLO: https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js
				- Toda vez q chama a propriedade set
				- Ele controla se determinado valor vai ser atualizado ou não
				- Sempre vai ter a função notify()
				- Toda vez q deleta também chama a função notify()
				*** A ideia é q toda vez q houver alterações no estado, quem estiver escutando vai ser avisado.
			*/
			// Exemplo de uma implementação em JS
			class Observable{
				constructor(){
					this.observers = [];// Tem q manter uma lista de observers (Item = subcribe)
				}
				subscribe(fn){
					this.observers.push(fn);// Função q adiciona subscribe na lista de observers
				}
				unsubscribe(fn){// Função q remove um subscribe da lista de observers
					this.observers = this.observers.filter(subscriber => subscriber !== fn);
				}
				notify(data){
					this.observers.forEach(fn => fn(data));
				}
			}
			const o = new Observable();// instanciando
			const logData1 = data => console.log('Subscribe 1: ' + data);// criando
			const logData2 = data => console.log('Subscribe 2: ' + data);// criando
			const logData3 = data => console.log('Subscribe 3: ' + data);// criando
			console.log(typeof logData1); // function
			o.subscribe(logData1);// incluindo
			o.subscribe(logData2);// incluindo
			o.subscribe(logData3);// incluindo
			o.notify('notificação de teste');
			o.unsubscribe(logData2);// excluindo
			o.notify('notificação de teste 2');

			// =============================== Design Pattern: Module ===============================
			// Exemplo de como era ANTES
			// // Criava-se uma função de execução imediata, passava o que ela precisava e fazia as alterações
			// (function($){
			// 	// your plugin here
			// })(JQuery);
			// Exemplo de como ficou DEPOIS com o ES6
			// Assim, conseguimos separar os arquivos de acordo com a responsabilidade
				// Exemplo de como criar com arquivos separados
					// //...cria em um arquivo...
					// class Person {
					// 	constructor(name){
					// 		this.name = name;
					// 	}
					// }
					// export default Person;
					// //...usa Person em outro arquivo...
					// import Person from './models/person';

					// // exemplo...
					// //const { getName, setName } = require ('module.exports.js'); // Importando o módulo
					// import { getName, setName } from 'module.exports.js'; // Importando o módulo
					// console.log(getName());
					// console.log(setName('Mariana'));
					// console.log(getName());					
		</script>
    </body>
</html>