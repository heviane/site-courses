<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>JavaScript</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
		<!--Página-Cabeçalho-->
		<header class="header"><h1>Curso JavaScript</h1></header>
		<!--Página-Conteúdo-->
		<section class="content">
            <header><h2 class="content_title"></h2></header>
            <article class="post">
                <header><h3>Callback e Promise</h3></header>
                <p class="post_content">
                    <h4>Callback</h4>
                        Nativamente era comum usar funções de callback para lidar com requisições assíncronas, para executar algo após determinada tarefa assíncrona ter sido executada.<br>
                        Forma muito verbosa!
                        <pre><code>
                            // Funções de Callback
                            function doSomething(callback) {
                                setTimeout(function() {
                                    callback('Executou! First data');
                                }, 1000);
                            }
                            function doOtherThing(callback) {
                                setTimeout(function() {
                                    callback('Executou! Second data');
                                }, 1000);
                            }

                            // Função Chamadora
                            function doAll(){
                                try{
                                    doSomething(function(data) {
                                        var processedData = 'Processed data: ' + data; 
                                        try{
                                            doOtherThing(function(data2) {
                                                var processedData2 = 'Processed data2: ' + data2;
                                                try{
                                                    setTimeout(function() {
                                                        console.log(processedData, processedData2)
                                                    }, 1000);
                                                }catch(e){
                                                    console.log(e);
                                                }
                                            });
                                        }catch(e){
                                            console.log(e);
                                        }
                                    });
                                }catch(e){
                                    console.log(e);
                                }
                            }

                            // Execução
                            doAll();
                        </code></pre>
                    
                    <h4>Promise (ES6)</h4>
                        Objeto que representa uma tarefa assíncrona.<br>
                        Não há necessidade de Try() e Catch(), se der algum erro, ele é tratado automaticamente no <b>reject</b>.
                        <ul><h4>Estados das promises:</h4>                      
                            <li><b>Pending:</b> A tarefa ainda não foi executada.</li>
                            <li><b>Fulfilled:</b> A tarefa foi executada com sucesso.</li>  
                            <li><b>Rejected:</b> A tarefa foi executada com erro.</li>
                        </ul>
                        <ul><h4>Formas de execução das promises:</h4>
                            <li>Sequencial</li>
                            <li>Paralelo</li>
                        </ul>
                        <pre><code>
                            // EXEMPLO: Retorna uma promise 
                                fetch('https://api.github.com/users')
                                    .then(response => { console.log(response); }); 
                                fetch('https://api.github.com/users/ivey')
                                    .then(response => { console.log(response); }); 

                            // EXEMPLO: Processando promise (response) para extrair os dados
                                fetch('https://api.github.com/users/ivey').then(response => {
                                        response.json().then(data => {
                                            console.log(data);
                                    });
                                }) 
                                fetch('https://api.github.com/users/ivey')
                                    .then(response => response.json())  
                                    .then(data => console.log(data))    
                                    .catch(e => console.log(e));   
                                                
                            // EXEMPLO: Encadeado de Promises
                            // Retornar promise no .then, encadear, aplica Tipo um flash map 
                                fetch('https://api.github.com/users/ivey')
                                    .then(response => { 
                                        return response.json() 
                                        .then(data => console.log(data));   
                                    });

                            // EXEMPLO: Erro de REDE (forçando error...chamando numa porta que não existe)
                                fetch('http://localhost:8099')
                                    .then(response => response.json())    
                                    .then(data => console.log(data))       
                                    .catch(e => console.log('Error: ', e));  
                                    // GET http://localhost:8099/ net::ERR_CONNECTION_REFUSED
                                    // Error:  TypeError: Failed to fetch     *** ERRO capturado pelo catch ***

                            // EXEMPLO: Erro de RESPONSE (forçando error...chamando arquivo que não existe)
                            // A request passou, então não é um erro de rede.
                            // O erro foi um status de resposta não desejado.
                                fetch('https://api.github.com/users/')
                                    .then(response => {
                                        if (response.status === 200) {
                                            return response.json();
                                        } else {
                                            throw new Error('Erro na requisição'); // Lançando erro...
                                        }
                                    }) 
                                    .then(data => console.log(data))   
                                    .catch(e => console.log('Error: ', e));    
                                    // GET https://api.github.com/users/ 404 Not Found
                                    // Error:  Error: Erro na requisição

                            // EXEMPLO: Fetch com método especificado (Padrão é GET) 
                                fetch('https://api.github.com/users/ivey', {
                                    method: 'POST',
                                    headers: {
                                        'Accept': 'application/json',
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        name: 'Michael D. Ivey',
                                        login: 'ivey',
                                        email: 'ivey@gmail.com'
                                    })
                                });
                        </code></pre>
                </p>

                <header><h3>Fetch e Async/Await</h3></header>
                <p class="post_content">
                    <h4>XMLHttpRequest</h4>
                        API do browser que trabalha com <b>Callback</b> para requisições HTTP, usada antes do ES6.

                    <h4>Fetch ES6</h4> 
                        API para requisições HTTP. Retorna uma <b>Promise</b>.<br>
                        Usar <b>then</b> para tratar o retorno.

                    <h4>Fetch ES7 - Async/Await</h4> 
                        <b>Async</b> é um modificador que permite executar a função de forma assíncrona.<br>
                        Transforma uma função em uma promise já resolvida.<br>
                        <b>Await</b> sempre vai estar dentro do async, espera que as promises sejam executadas/resolvidas.
                        <ul>Duas formas de processamento:
                            <li>Processamento assincrono sequencial</li>
                            <li>Processamento assincrono paralelo</li>
                        </ul>
                </p>

                <header><h3>EventEmitter</h3></header>
                <p class="post_content">
                    É uma forma diferente de lidar com programação assíncrona dentro do Node. Exclusivo do <b>node.js</b>.<br>
                    Classe que permite a criação de eventos. <br>
                    Disponibilizada através do módulo 'events'.
                    <pre><code>
                        const EventEmitter = require('events');
                    </code></pre>

                    <ul><h4>Formas de uso:</h4>
                        <li>Instanciar a classe</li>
                            <pre><code>
                                const emitter = new EventEmitter(); 
                                emitter.on('User Logged', data => { console.log(data); });
                                emitter.emit('User Logged', { id: 1, name: 'Ana Rodrigues' });
                            </code></pre>
                        <li>Extender a classe</li>
                            A vantagem é poder personalizar o comportamento da classe.
                            <pre><code>
                                class Users extends EventEmitter {
                                    userLogged(data){
                                        setTimeout(() => {
                                            this.emit('User Logged', data);
                                        }, 1000);
                                    }
                                }
                                const user = new Users();
                                user.on('User Logged', data => { console.log(data); });
                                user.userLogged({ id: 1, name: 'Pedro Oliveira' });
                                user.userLogged({ id: 2, name: 'Maria Silva' });
                            </code></pre>
                        <li>Método once()</li>
                            Permite que o evento seja executado apenas uma vez.
                            <pre><code>
                                user.once('User Logged', data => { console.log(data); });
                                user.userLogged({ id: 1, name: 'Heviane Bastos' }); 
                                user.userLogged({ id: 2, name: 'Diego Fernandes' });
                            </code></pre>
                    </ul>                    
                    
                    <b class="text-red">OBS:</b> EventListener é uma API similar, exclusiva do browser, porém mais limitada.<br>
                    EventTarget é a classe que permite a criação de eventos.<br>
                    Podemos fazer <b>add eventListener()</b> e depois fazer <b>dispatchEvent()</b>.
                </p>
            </article>

            <article class="post">
                <header><h3>References</h3></header> 
                <p>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Synchronous"
                        target="_blank">Synchronous</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous"
                        target="_blank">Asynchronous</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function"
                        target="_blank">Callback function</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
                        target="_blank">Promise</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
                        target="_blank">Promise then</a></li>
                    <li><a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"
                        target="_blank">Promise catch</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest"
                        target="_blank">API XMLHttpRequest</a></li>
                        <!-- Não tratado aqui...ainda
                            https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events
                            https://developer.mozilla.org/en-US/docs/Web/API/EventSource
                            https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API 
                        -->
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch"
                        target="_blank">API fetch</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"
                        target="_blank">API request</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"
                        target="_blank">API response</a></li>
                </p>          
            </article>
        </section>
        <!--Página-Rodapé-->
        <footer class="footer">
            <div class="footer_list">
                <li><a href="https://www.linkedin.com/in/heviane-bastos" target="_blank">linkedin</a></li>
                <li><a href="https://github.com/heviane" target="_blank">github</a></li>				
            </div>
        </footer>
    </body>
</html>