<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
    <link rel="stylesheet" href="https://heviane.github.io/shared-styles/simple-site-v1/assets/css/style.css">
</head>

<body>
    <!--Página-Cabeçalho-->
    <header class="header">
        <h1>Orientação à Objeto Baseada em Protótipo</h1>
    </header>
    <!--Página-Conteúdo-->
    <section class="content">
        <header>
            <h2 class="posts_title"></h2>
        </header>
        <article class="post">
            <header>
                <h3>Introdução</h3>
            </header>
            <p class="post_content">
                <p>É um paradigma de programação baseada em <b>protótipo</b>, que é um <b>estilo de programação orientada a objetos</b>.</p>
                <p>A reutilização de comportamento é realizada por meio de um processo de reutilização de objetos existentes que servem como protótipos.</p>
                <p>Todos os objetos herdam propriedades e métodos de um prototype. O objeto <b>Object.prototype</b> está no topo desta cadeia.</p>
                <p>Esse modelo também pode ser conhecido como programação prototípica, orientada a protótipos, sem classes ou baseada em instâncias.</p>
                <p>Aplicável em todos os tipos de dados não primitivos.</p>
            </p>
        </article>

        <article class="post">
            <header>
                <h3>Herança</h3>
            </header>
            <p class="post_content">
                <p>A herança é feita por meio de protótipos, cadeia de protótipos, onde vai herdando propriedades e métodos até o topo da cadeia.
                O topo da cadeia é a classe <b>Object</b>.</p>
                <ul>
                    <li><b>prototype</b>: É uma variável que armazena as definições do objeto.</li>
                    Possui todas as propriedades e métodos herdados.
                    <li><b>__proto__</b>: Referência a variável prototype.</li>
                    Aponta para um prototype, que é criado a partir de uma função constructor.
                    <li><b>constructor</b>: É o nome da função que cria o objeto. Aponta para o prototype.</li>
                </ul>
                <p class="important">Tudo isso o JS faz por debaixo dos panos.</p>
            </p>
        </article>

        <article class="post">
            <header>
                <h3>Classes</h3>
            </header>
            <p class="post_content">
                <p>Classes não existem nativamente no JS, elas são uma <b>Syntatic Sugar</b>, ou seja, uma sintaxe feita para facilitar a escrita. Criada no ES6.</p>
                <p>Todas as classes são objetos e a herança se dá por <b>protótipos</b>.</p>
                <p>É uma forma simplificada para funções "fábricas" (Factory Functions), que é uma função que retorna um objeto, instância da classe especificada.</p>
                <p><b>class</b> é uma palavra chave para declarar uma classe. É super sintaxe das funções.</p>                
                <p><b class="important">OBS</b>: Por baixo dos panos é criado um prototype para cada classe.<br>
                Link para testar e verificar em: <a href="https://babeljs.io/" target="_blank">https://babeljs.io/</a></p>
            </p>
        </article>

        <article class="post">
            <header>
                <h3>Modificadores de Acesso</h3>
            </header>
            <p class="post_content">
                <p>JS não tem modificadores de acesso, porém existe uma implementação no ES6 que permite a definição de modificadores de acesso na versão 12
                Node.js, mas, ainda não tem suporte nos browsers.</p>
                <ul>
                    <li><b>Public</b></li>
                    <li><b>Private</b></li>
                        <b>#</b>: É o caractere que determina o modificador de acesso PRIVADO.
                </ul>
            </p>
        </article>

        <article class="post">
            <header>
                <h3>Class-based vs. prototype-based languages</h3>
            </header>
            <p class="post_content">
                <ul>
                    <li>Linguagem <b>orientada à objetos baseada em classes</b></li>
                    Baseiam-se no conceito de duas entidades distintas: classes e instâncias.<br>

                    Uma <b>classe</b> é abstrata, pois define todas as propriedades que caracterizam um determinado conjunto
                    de objetos.
                    Por exemplo, a classe Employee pode representar o conjunto de todos os funcionários.<br>

                    Uma <b>instância</b> (objeto), por outro lado, é a instanciação de uma classe.
                    Por exemplo, Victoria poderia ser uma instância da classe Employee, representando um determinado
                    indivíduo como funcionário.
                    Uma instância tem exatamente as mesmas propriedades de sua classe pai (nem mais, nem menos).<br><br>

                    <li>Linguagem <b>orientada à objetos baseada em protótipos</b></li>
                    Baseia-se no conceito de objeto, não faz distinção entre classe e instância.<br>

                    Tem a noção de um objeto prototípico, um objeto usado como modelo para obter as propriedades
                    iniciais de um novo objeto. Qualquer objeto pode especificar suas próprias propriedades,
                    quando você o cria ou em tempo de execução.<br>
                    Além disso, qualquer objeto pode ser associado como protótipo de outro objeto,
                    permitindo que o segundo objeto compartilhe as propriedades do primeiro objeto.
                </ul>
            </p>
        </article>

        <article class="post">
            <header>
                <h3>Class-based vs. prototype-based languages</h3>
            </header>
            <p class="post_content">
            <div class="table-responsive">
                <table class="table align-middle">
                    <thead>
                        <tr></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Categoria</b></td>
                            <td><b>Baseado em classe (Java)</b></td>
                            <td><b>Baseado em protótipo (JavaScript)</b></td>
                        </tr>
                        <tr>
                            <td>Classe x instância</td>
                            <td>Classe e instância são entidades distintas.</td>
                            <td>Todos os objetos podem herdar de outro objeto.</td>
                        </tr>
                        <tr>
                            <td>Definição</td>
                            <td>Defina uma classe com uma definição de classe; instanciar uma classe com métodos
                                construtores.</td>
                            <td>Defina e crie um conjunto de objetos com funções construtoras.</td>
                        </tr>
                        <tr>
                            <td>Criação de um novo objeto</td>
                            <td>Crie um único objeto com o newoperador.</td>
                            <td>Mesmo</td>
                        </tr>
                        <tr>
                            <td>Construção da hierarquia de objetos</td>
                            <td>Construa uma hierarquia de objetos usando definições de classe para definir subclasses
                                de classes existentes.</td>
                            <td>Construa uma hierarquia de objetos atribuindo um objeto como o protótipo associado a uma
                                função construtora.</td>
                        </tr>
                        <tr>
                            <td>Modelo de herança</td>
                            <td>Herde propriedades seguindo a cadeia de classes.</td>
                            <td>Herde propriedades seguindo a cadeia de protótipos.</td>
                        </tr>
                        <tr>
                            <td>Extensão de propriedades</td>
                            <td>A definição de classe especifica todas as propriedades de todas as instâncias de uma
                                classe.
                                Não é possível adicionar propriedades dinamicamente em tempo de execução.</td>
                            <td>A função construtora ou protótipo especifica um conjunto inicial de propriedades.
                                Pode adicionar ou remover propriedades dinamicamente para objetos individuais ou para
                                todo o conjunto de objetos.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p class="important">Classes são mais rigidas e protótipos são mais flexíveis.</p>
            </p>
        </article>

        <article class="post">
            <header>
                <h3>Exemplos ES5 e ES6</h3>
            </header>
            <p class="post_content">
                <p>Como era no ES5 vs. como é no ES6 com a criação da <b>Syntatic Sugar</b>.</p>
                <p><img src="../../assets/img/concepts/orientacao-a-objeto-baseada-em-prototipo.png"></p>
            </p>
        </article>

        <header>
            <h2 class="posts_title">References</h2>
        </header>
        <article class="post">
            <p class="post_content">

            </p>
        </article>
    </section>
    <!--Página-Rodapé-->
    <footer class="footer">
        <div class="footer_list">
            <li><a href="https://www.linkedin.com/in/heviane-bastos" target="_blank">linkedin</a></li>
            <li><a href="https://github.com/heviane" target="_blank">github</a></li>
        </div>
    </footer>
    <script>
        // 'use strict'; //Força o JS a ser mais rigoroso

        // //============================================== HERANÇA 

        // --- Example 1 
        const myText = 'Hello prototype';
        // myText.constructor -> String (O construtor do myText é uma String)
        // myText.__proto__ APONTA para String.prototype
        myText.split(' '); // ??? De onde vem esse Split ???

        // --- Example 2 - Toda variável criada com uma função construtora tem a referência do prototype dela.
        const myText2 = String('Hello prototype'); // Função construtura String
        console.log(myText2.__proto__.split);
        console.log(String.prototype.split); // ƒ split() { [native code] }
        console.log(myText2.__proto__.split === String.prototype.split); // true __proto__ aponta para String.prototype
        console.log(myText2.constructor === String); // true - O constructor da variavel myText2 é um objeto String.

        // --- Example 3
        function Animal() { this.qtdePatas = 4; }
        console.log(Animal.constructor);
        // O prototype.constructor da função (Animal) aponta para Function.
        // O prototype.constructor do Function aponta para Object. O prototype do Function é Object.prototype.
        console.log(Function.prototype);             // ƒ () { [native code] }
        console.log(Function.prototype.constructor); // ƒ Function() { [native code] }
        console.log(Function.__proto__);             // ƒ () { [native code] }
        // O prototype do Object é null. É o objeto raiz.
        console.log(Object.prototype);             // null (Não tem nada porque é a estrutura padrão raiz)
        console.log(Object.prototype.constructor); // ƒ Object() { [native code] }
        console.log(Object.__proto__);             // ƒ () { [native code] }
        // Criando um objeto do tipo Animal
        const cao = new Animal();
        console.log(cao.qtdePatas); // 4
        console.log(cao.__proto__ === Animal.prototype);      // true (__proto__ aponta p prototype de Animal (Função construtora)).
        console.log(Animal.__proto__ === Function.prototype); // true (__proto__ aponta p prototype de Function (Função construtora)).

        //============================ NEW
        /* --------- new Foo(...)
            Cria um novo objeto do tipo Foo, herdando Foo.prototype. 
                A função construtora Foo é chamada com os argumentos especificados.
                Caso a função construtora tenha um retorno explicito, será respeitado seu valor.
                Caso contrário, será retornado o objeto criado.
                    O this aponta para o novo objeto criado.
            O this.constructor e Foo.prototype.constructor aponta para Foo.
            O this.__proto__ aponta para Foo.prototype.
            O Foo.prototype aponta para Object.prototype.
                O Object.prototype.constructor aponta para Object.
                O Object.prototype aponta para null.*/
        // --------- Exemplo de retorno implicito = Retorna o objeto criado.
        const p1 = new Pessoa('João');
        console.log(p1); // Pessoa { name: 'João' }   // Constructor: Pessoa, Prototype: Object
        // --------- Exemplo de retorno explicito = Respeita o return.
        function Pessoa(name) {
            this.name = name;
            return { name: 'Teste retorno explicito' };
        }
        const p2 = new Pessoa('João');
        console.log(p2); // {name: 'Teste retorno explicito'}

        //============================ Descobrir a instância de um objeto.
        console.log(cao instanceof Animal);   // true  (cão é um objeto do tipo Animal, é uma instância de Animal)
        console.log(cao instanceof Function); // false   

        //============================ Exemplo de Derivação
        // --- Criando propriedades na própria função construtora
        function Animal(qtdePatas) {
            this.qtdePatas = qtdePatas;
            this.movimentar = function () { }
        }
        console.log(Animal.constructor); // Function() { [native code] } *** Constructor de Animal é function ***

        function Cao(morde) { // Função construtora derivada da função Animal
            Animal.call(this, 4); // this = Passando contexto de cao para Animal.call(). this de Animal vai ser o objeto criado aqui.
            this.morde = morde;
            this.latir = function () { console.log('Au au'); }
        }
        console.log(Cao.constructor); // Function() { [native code] } *** Constructor de Cao é function ***

        const pug = new Cao(false);
        console.log(pug);
        const pitbull = new Cao(true);
        console.log(pitbull);

        // --- Criando propriedades no prototype da função construtora.
        function Animal() { }
        Animal.prototype.qtdePatas = 0;
        Animal.prototype.movimentar = function () { };
        function Cao(morde) {
            this.qtdePatas = 4;
            this.morde = morde;
        }
        Cao.prototype = Object.create(Animal);
        Cao.prototype.latir = function () { console.log('Au au'); }
        const pug2 = new Cao(false);
        console.log(pug2);
        console.log(pug2.latir()); // Au au
        const pitbull2 = new Cao(true);
        console.log(pitbull2);
        /* ********** DIFERENÇA das versões *******
            Versão 1: Deriva a partir das funções.
                - As função são criadas toda vez que um objeto é instanciado.
            Versão 2: Deriva a partir dos prototypes (definições).
                - As função NÃO são criadas toda vez que um objeto é instanciado, pois já estão definidas no prototype.
                - Vantagens:
                    - Padronizar, valores que devem existir em todos os objetos.
                    - Adição de novas propriedades no prototype já são refletidas automaticamente em objetos já criados.      
        */
        console.log(pug2.__proto__);
        Cao.prototype.teste = function () { console.log('Teste'); }; // Novas adds, já são refletidas em objetos já criados.
        console.log(pug2.__proto__); // Todas as instânicas vão receber essa atualização.

        // --------------------- Prototype é um recurso bem interessante, mas também é perigoso
        // Permiti trocar a implementação de um tipo nativo. **** NÃO RECOMENDADO fazer isso ****
        // Ao trocar o prototype de uma função, todos os objetos criados a partir dela, recebem o novo prototype.
        // Exemplo com o Objeto nativo String
        '123456'.split(''); // [ '1', '2', '3', '4', '5', '6' ]
        String.prototype.split = function () { console.log('ixi...'); }
        '123456'.split(''); // ixi...
        //============================================== CLASSES - ES6 
        // É uma simplificação da herança de protótipos.
        // É uma função que cria objetos a partir de seu modelo.

        // --- Declaração como função
        class Animal {
            constructor(qtdePatas) {
                this.qtdePatas = qtdePatas;
            }
            movimentar() {
                console.log('Movimentando...');
            }
        }
        // --- Declaração como classe
        class Cao extends Animal {
            constructor(morde) {
                super(4);
                this.morde = morde;
            }
            latir() {
                console.log('Au au');
            }
        }
        const pug3 = new Cao(false);
        console.log(pug3);
        //============================================== Modificadores de Acesso 
        // --- Declaração como função
        function Person(nameIn) {
            let name = nameIn;
            this.getName = function () {
                return name;
            }
            this.setName = function (nameOut) {
                name = nameOut;
            }
        }
        const p = new Person('João');
        p.getName(); // João
        p.setName('Maria');
        p.getName(); // Maria
        p.name = 'João'; // Não é possível. 
        // --- Declaração como classe (Faz a mesma coisa...mas com o modificador de acesso # da versão 12 do Node.js)
        class Person {
            #name = '';
            constructor(nameIn) {
                this.#name = nameIn;
            }
            setName(name) {
                this.#name = name;
            }
            getName() {
                return this.#name;
            }
        }
        const p3 = new Person('João');
        p3.getName(); // João
        p3.setName('Maria');
        p3.getName(); // Maria
        p3.name = 'Paulo'; // Não é possível.
        //============================================== Encapsulamento 
        // Ocultar detalhes do funcionamento interno de um objeto.
        // --- Declaração como função
        function Person(nameIn) {
            var name = nameIn;
            Object.defineProperty(this/*contexto q vai ser criada essa var*/, 'name', {
                get: function () {
                    return name;
                },
                set: function (value) {
                    name = value;
                }
            });
        }
        // --- Declaração como classe
        class Person {
            #name = '';
            constructor(name) {
                this.#name = name;
            }
            get name() { // palavra chave get para determinado att
                return this.#name;
            }
            set name(name) { // palavra chave set para determinado att
                this.#name = name;
            }
        }
        //============================================== Static ========================================
        // Acessar métodos/atributos sem precisar instânciar um objeto.
        // --- Declaração como função
        function Person() {
            Person.walk = function () {
                console.log('walking...');
            }
        }
        console.log(Person.walk()); // walking...
        // --- Declaração como classe
        class person {
            static walk() {
                console.log('walking...');
            }
        }
        console.log(Person.walk()); // walking...

        /* ------------------------------------ RESUMINDO...
            Herança é baseada em protótipos.
            É possível instânciar (criar) um objeto a partir de uma função ou de uma classe.
            Uma classe é uma simplificação da herança de protótipos. 
                É uma função que cria objetos a partir de seu modelo. 
            Funções construtoras, por convenção, a primeira letra é maiúscula.
        */
        class DogClass {
            constructor(name) {
                this.name = name;
            }
        }
        function DogFunction(name) {
            return {
                name,
            }
        }
        const pintcher = new DogClass('Hulk');
        const labrador = new DogFunction('Bruno');
        typeof pintcher === typeof labrador; // true
    </script>
</body>

</html>